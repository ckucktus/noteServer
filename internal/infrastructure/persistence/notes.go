package persistence

import (
	"database/sql"
	"fmt"
	"github.com/lib/pq"
	"test_task/internal/domain/entity"
)

type NoteStorage struct {
	db *sql.DB
}

type Note struct {
	noteText string
}

func NewNoteStorage(dsn string) (NoteStorage, error) {
	const op = "infrastructure.persistence.NewNoteStorage"

	parsedURL, err := pq.ParseURL(dsn)
	if err != nil {
		return NoteStorage{}, err
	}
	db, err := sql.Open("postgres", parsedURL)

	if err != nil {
		return NoteStorage{}, err
	}

	stmt, err := db.Prepare(`
		CREATE TABLE IF NOT EXISTS Notes
		(
			note_id integer not null generated by default as identity(increment 1 minvalue 1 start 1 cache 1),
			author_id int,
			note    TEXT NOT NULL,
			CONSTRAINT author
				FOREIGN KEY (author_id)
					REFERENCES Users (user_id)
		);
	`)
	if err != nil {
		return NoteStorage{}, fmt.Errorf("%s: %w", op, err)
	}

	_, err = stmt.Exec()
	if err != nil {
		return NoteStorage{}, fmt.Errorf("%s: %w", op, err)
	}

	return NoteStorage{db: db}, nil
}

func (s NoteStorage) SaveNote(NoteText string, authorId int64) (int64, error) {
	const op = "infrastructure.persistence.SaveNote"
	// todo добавить контекст в зпросы к бд
	var id int64
	stmt, err := s.db.Prepare("INSERT INTO Notes(note, author_id) VALUES($1, $2) RETURNING note_id")
	if err != nil {
		return 0, fmt.Errorf("%s: %w", op, err)
	}

	err = stmt.QueryRow(NoteText, authorId).Scan(&id)
	if err != nil {
		return 0, fmt.Errorf("%s: %v", op, err)
	}
	if err != nil {
		return 0, fmt.Errorf("%s: %v", op, err)
	}

	if err != nil {
		return 0, fmt.Errorf("%s: failed to get last insert id: %w", op, err)
	}

	return id, nil
}

func (s NoteStorage) GetNotes(AuthorId int64) ([]entity.Note, error) {
	const op = "infrastructure.persistence.SaveNote"
	// todo добавить контекст в зпросы к бд

	rows, err := s.db.Query("SELECT note_id, note FROM Notes WHERE author_id = $1", AuthorId)
	if err != nil {
		return make([]entity.Note, 0), fmt.Errorf("%s: %w", op, err)
	}
	result := make([]entity.Note, 0, 10)
	for rows.Next() {
		var res entity.Note
		err := rows.Scan(&res.Id, &res.NoteText)
		if err != nil {
			return make([]entity.Note, 0), fmt.Errorf("%s: %v", op, err)
		}
		result = append(result, res)
	}

	return result, nil
}
